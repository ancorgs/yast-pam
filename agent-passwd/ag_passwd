#!/usr/bin/perl -w

use lib "/usr/lib/YaST2/agents_non_y2";
use ycp;
use strict;

my $max_system_uid	= 499;
my $max_system_gid	= 499;

my %last_uid		= (
    "local"	=> $max_system_uid + 1,
    "system"	=> 0
);

my %users		= ();
my %groups		= ();
my %shadow_tmp		= ();
my %shadow		= ();

# used for check if values like uid,username are unique:
my %uids		= ();
my %usernames		= ();
my %homes		= (); 
my %gids		= ();
my %groupnames		= ();

my %users_groups	= ();

my %users_by_name	= ();
my %groups_by_name	= ();

my $plus_line_group 	= "";
my $plus_line_passwd	= "";
my $plus_line_shadow	= "";

# error number
my $errno		= 0;

#more information about the error
my $error_info		= "";

# directory where user/group/shadow data should be found
my $base_directory	 = "/etc";

#---------------------------------------------
# read /etc/shadow and prepare global 'shadow_tmp' structure

sub read_shadow {

    %shadow_tmp	= ();

    my $o = open SHADOW, "< $base_directory/shadow";
    if (!defined $o) {
	y2warning ("$base_directory/shadow cannot be opened for reading!");
	return 0;
    }

    foreach my $shadow_entry (<SHADOW>)
    {
	chomp $shadow_entry;

	my ($uname,$pass,$last_change,$min, $max, $warn, $inact, $expire, $flag)
	    = split(/:/,$shadow_entry);  
        my $first = substr ($uname, 0, 1);

	if ($first eq "#") {
	    y2warning ("Found comment line in shadow file: '$shadow_entry'");
	    y2warning ("It will be lost on write!");
	}
	elsif ($first ne "+" && $first ne "-")
	{
	    if ($uname eq "") {
		y2error ("strange line in shadow file: '$shadow_entry'");
		$errno 		= 9;
		return 9;
	    }

	    if (defined $shadow_tmp{$uname})
	    {
		y2error ("duplicated username in /etc/shadow! Exiting...");
		$errno		= 3;
		$error_info 	= $uname;
		return 3;
	    }
	    $shadow_tmp{$uname} = {
		"shadowLastChange"	=> $last_change || 0,
		"shadowWarning"		=> $warn,
		"shadowInactive"	=> $inact,
		"shadowExpire"		=> $expire,
		"shadowMin"		=> $min		|| 0,
		"shadowMax"		=> $max		|| 0,
		"shadowFlag"		=> $flag,
		"userPassword"		=> $pass	|| ""
	    };
	}
	else # plus line in /etc/shadow
	{
	    $plus_line_shadow = $shadow_entry;
	}
    }
    close SHADOW;
    return 0;
}

#---------------------------------------------
# read /etc/group and prepar global 'users_groups' structure

sub read_group {

    %groups	= ();
    %gids	= ();
    %groupnames	= ();

    my $o = open GROUP, "< $base_directory/group";
    if (!defined $o) {
	y2warning ("$base_directory/group cannot be opened for reading!");
	return 0;
    }

    foreach my $group (<GROUP>) {
	
	chomp $group;
        my ($groupname, $pass, $gid, $users) = split (/:/,$group);
	my $first = substr ($groupname, 0, 1);

	if ($first eq "#") {
	    y2warning ("Found comment line in group file: '$group'");
	    y2warning ("It will be lost on write!");
	}
        elsif ( $first ne "+" && $first ne "-" ) {
	    
	    if (!defined $pass || !defined $gid || !defined $users ||
		$gid eq "") {
		y2error ("strange line in group file: '$group'");
		$errno 		= 8;
		$error_info 	= "$group";
		return 8;
	    }
		
	    my $group_type = "local";
	    if (($gid <= $max_system_gid || $groupname eq "nobody" ||
		 $groupname eq "nogroup") &&
		($groupname ne "users"))
	    {
		$group_type = "system";
	    }

            # check for duplicates...
	    if (defined $gids{"local"}{$gid}  || defined $gids{"system"}{$gid})
	    {
		y2error ("duplicated gid ($gid) in /etc/group! Exiting...");
		$errno		= 5;
		$error_info 	= "$gid";
		return 5;
	    }
	    else
            {
	        $gids{$group_type}{$gid} = 1;
	    }

            if (defined $groupnames{"local"}{$groupname} ||
		defined $groupnames{"system"}{$groupname})
            {
	        y2error ("duplicated groupname in /etc/group! Exiting...");
		$errno		= 6;
		$error_info 	= $groupname;
	        return 6;
            }
	    else
	    {
		$groupnames{$group_type}{$groupname} = 1;
            }
            # for each user generate list of groups, where the user is contained
	    my @userlist	= split(/,/,$users);
	    my %userlist	= ();
	    foreach my $u (@userlist) {
		$userlist{$u}			= 1;
		$users_groups{$u}{$groupname}	= 1;
	    }
	    $groups{$group_type}{$gid} = {
		"groupname"	=> $groupname,
		"gidNumber" 	=> $gid,
		"userlist"	=> \%userlist,
		"type"		=> $group_type,
		"more_users"	=> {}
	    };

	    $groups_by_name{$group_type}{$groupname} = $gid;
	}
	else # save the possible "+"/"-" entries
        {
	    $plus_line_group = $group;
        }
    }
    close GROUP;
    return 0;
}

# --------------------------------------------------------------------
# read /etc/passwd

sub read_passwd {

    my $o = open PASSWD, "< $base_directory/passwd";
    if (!defined $o) {
	y2warning ("$base_directory/passwd cannot be opened for reading!");
	return 0;
    }

    %users 	= ();
    %shadow	= ();
    %uids	= ();
    %usernames	= ();
    %homes	= ();

    foreach my $user (<PASSWD>) {

	chomp $user;
	my ($username, $password, $uid, $gid, $full, $home, $shell)
	    = split(/:/,$user);
        my $first = substr ($username, 0, 1);

	if ($first eq "#") {
	    y2warning ("Found comment line in passwd file: '$user'");
	    y2warning ("It will be lost on write!");
	}
	elsif ($first ne "+" && $first ne "-") {

	    if (!defined $password || !defined $uid || !defined $gid ||
		!defined $full || !defined $home || !defined $shell ||
		$username eq "" || $uid eq "" || $gid eq "") {
		y2error ("strange line in passwd file: '$user'");
		$errno 		= 7;
		$error_info 	= "$user";
		return 7;
	    }
		
            my $user_type	= "local";
	    my $group_type	= "";
	    my $groupname	= "";
	    my %grouplist	= ();

	    if (defined $groups{"system"}{$gid})
	    {
		$group_type = "system";
	    }
	    if (defined $groups{"local"}{$gid})
	    {
		$group_type = "local";
	    }
	    if ($group_type ne "")
	    {
		$groupname = $groups{$group_type}{$gid}{"groupname"};
	    
		# modify default group's more_users entry
		$groups{$group_type}{$gid}{"more_users"}{$username}	= 1;
	    }

	    # add the grouplist
	    if (defined $users_groups{$username}) {
		%grouplist = %{$users_groups{$username}};
	    }

	    if (($uid <= $max_system_uid) || ($username eq "nobody")) {
		$user_type = "system";
		if ($last_uid{"system"} < $uid  && $username ne "nobody") {
		    $last_uid{"system"} = $uid;
		}
	    }
	    else {
		if ($last_uid{"local"} < $uid) {
		    $last_uid{"local"} = $uid;
		}
	    }
	    # recode the fullname to utf-8 FIXME (and back during write)
	    # use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR CODESET);
	    # my $encoding = langinfo CODESET;
	    my $encoding = "";
	    if ($encoding ne "") {
		from_to ($full, $encoding, "utf-8");
	    }
    
	    my $colon = index ($full, ",");
	    my $additional = "";
	    if ( $colon > -1)
	    {
		$additional = $full;
		$full = substr ($additional, 0, $colon);
		$additional = substr ($additional, $colon + 1,
		    length ($additional));
	    }

            # check for duplicates in /etc/passwd:
	    if (defined $uids{"local"}{$uid}  || defined $uids{"system"}{$uid})
	    {
		y2error ("duplicated UID in /etc/passwd! Exiting...");
		$errno 		= 1;
		$error_info 	= "$uid";
		return 1;
	    }
            else
	    {
	        $uids{$user_type}{$uid} = 1;
            }
	    
	    if (defined $usernames{"local"}{$username} ||
		defined $usernames{"system"}{$username})
	    {
		y2error ("duplicated username in /etc/passwd! Exiting...");
		$errno = 2;
		$error_info 	= $username;
		return 2;
	    }
	    else
	    {
		$usernames{$user_type}{$username} = 1;
	    }
	    if ($home ne "")
	    {
		$homes{$user_type}{$home} = 1;
	    }
    
	    my @grouplist	= keys (%grouplist);

	    # such map we would like to export from the read script...
	    $users{$user_type}{$uid} = {
		"cn"		=> $full,
		"homeDirectory"	=> $home,
		"username"	=> $username,
		"uidNumber"	=> $uid,
		"gidNumber"	=> $gid,
		"loginShell"	=> $shell,
		"groupname"	=> $groupname,
		"grouplist"	=> \%grouplist,
		"userPassword"	=> "x",
		"type"		=> $user_type
	    };

	    if (! defined $shadow_tmp{$username}) {
		y2debug ("There is no shadow entry for user $username.");
	    }
	    else {
		# divide shadow map accoring to user type
		$shadow{$user_type}{$username} = $shadow_tmp{$username};
	    }

	    $users_by_name{$user_type}{$username} = $uid;
	}
	else # the "+" entry in passwd
	{
	    $plus_line_passwd = $user;
	}
    }
    close PASSWD;
    return 0;
}

#---------------------------------------------
# write map of users to the file

sub write_passwd {

    my %users_w		= %{$_[0]};

    # do not allow user to remove whole passwd
    if (!%users_w) {
	%users_w	= %users;
    }

    my $o = open PASSWD, "> $base_directory/passwd";
    if (!defined $o) {
	y2error ("$base_directory/passwd cannot be opened for writing!");
	$errno		= 100;
	return 0;
    }

    foreach my $type (sort {$b cmp $a} keys %users_w ) {

	foreach my $uid (sort {$a <=> $b} keys %{$users_w{$type}}) {

	    my %user	= %{$users_w{$type}{$uid}};
	    my $pass	= "x";
	    my $userline	= join (":", (
		$user{"username"} || "",
		$pass,
		$uid,
		$user{"gidNumber"} || 0,
		$user{"cn"} || "",
		$user{"homeDirectory"} || "",
		$user{"loginShell"} || "",
	    ));
	    if (defined $userline) {
		print PASSWD "$userline\n";
	    }
	}
    }
    if ($plus_line_passwd ne "") {
	print PASSWD "$plus_line_passwd\n";
    }
    close PASSWD;
    return 1;
}

#---------------------------------------------
# write map of shadow info to the file

sub write_shadow {

    my %shadow_w	= %{$_[0]};

    my $o = open SHADOW, "> $base_directory/shadow";
    if (!defined $o) {
	y2error ("$base_directory/shadow cannot be opened for writing!");
	$errno		= 101;
	return 0;
    }

    foreach my $type (sort {$b cmp $a} keys %shadow_w ) {

        foreach my $uname (sort keys %{$shadow_w{$type}}) {

	    my %shadow_entry	= %{$shadow_w{$type}{$uname}};
	    my $shadowline	= join (":", (
		$uname,
		$shadow_entry{"userPassword"} || "",
		$shadow_entry{"shadowLastChange"} || 0,
		$shadow_entry{"shadowMin"} || 0,
		$shadow_entry{"shadowMax"} || 0,
		$shadow_entry{"shadowWarning"},
		$shadow_entry{"shadowInactive"},
		$shadow_entry{"shadowExpire"},
		$shadow_entry{"shadowFlag"}
	    ));
	    if (defined $shadowline) {
		print SHADOW "$shadowline\n";
	    }
	}
    }
    if ($plus_line_shadow ne "") {
	print SHADOW "$plus_line_shadow\n";
    }
    close SHADOW;
}


#---------------------------------------------
# write map of groups to the file

sub write_group {

    my %groups_w = %{$_[0]};

    # do not allow user to remove whole group
    if (!%groups_w) {
	%groups_w	= %groups;
    }

    my $o = open GROUP, "> $base_directory/group";
    if (!defined $o) {
	y2error ("$base_directory/group cannot be opened for writing!");
	$errno		= 102;
	return 0;
    }

    # sort order: system items go before local ones
    foreach my $type (sort {$b cmp $a} keys %groups_w ) {

	# sort order: id
        foreach my $gid (sort {$a <=> $b} keys %{$groups_w{$type}}) {

	    my %group	= %{$groups_w{$type}{$gid}};
	    my $pass	= "x";
	    if (defined $group{"userPassword"}) {
		$pass 	= $group{"userPassword"};
	    }
	    my @group_entry	= (
		$group{"groupname"},
		$pass,
		$gid,
		join (",", sort keys %{$group{"userlist"}})
	    );
	    my $groupline	= join (":", @group_entry);

	    if (defined $groupline) {
		print GROUP "$groupline\n";
	    }
	}
    }
    if ($plus_line_group ne "") {
	print GROUP "$plus_line_group\n";
    }
    close GROUP;
}



sub read_all () {

    my $error = 0;

    $error = read_shadow ();
    
    if ($error == 0) {
	$error = read_group ();
    }
    if ($error == 0) {
	$error = read_passwd ();
    }
    return $error;
}


# --------------------------------------- main -----------------------------
while ( <STDIN> )
{

    my ($command, $path, $argument) = ycp::ParseCommand ($_);

    y2debug ("command: $command, path: $path");
    
    if ( $command eq "Execute" ) {
    
	if ( $path eq '.init' ) {
	    if (ref ($argument) eq "HASH") {
		if (defined ($argument->{"max_system_uid"})) {
		    $max_system_uid	= $argument->{"max_system_uid"};
		}
		if (defined ($argument->{"max_system_gid"})) {
		    $max_system_gid	= $argument->{"max_system_gid"};
		}
		if (defined ($argument->{"base_directory"})) {
		    $base_directory	= $argument->{"base_directory"};
		}
	    }
	    my $error = read_all ();
	    if ($error > 0) {
		ycp::Return ("false");
	    }
	    else {
		ycp::Return("true");
	    }
	}
	else {
	    y2error ("wrong path ($path) or argument type:", ref ($argument));
	    ycp::Return("false");
	}
    }
    elsif ( $command eq "Read" ) {

	# check if initialization was done
	if (!%users && $path ne '.error' && $path ne '.error.info') {
	    my $error = read_all ();
	    if ($error > 0) {
		ycp::Return ({});
	    }
	}
	if ($path eq '.error') {
	    ycp::Return ($errno);
	}
	elsif ($path eq '.error.info') {
	    ycp::Return ($error_info);
	}
	elsif    ( $path eq '.local.users' ) {
	    ycp::Return (\%{$users{"local"}});
	}
	elsif ( $path eq '.system.users' ) {
	    ycp::Return (\%{$users{"system"}});
	}
	elsif ( $path eq '.local.shadow' ) {
	    ycp::Return (\%{$shadow{"local"}});
	}
	elsif ( $path eq '.system.shadow' ) {
	    ycp::Return (\%{$shadow{"system"}});
	}
	elsif ( $path eq '.local.groups' ) {
	    ycp::Return (\%{$groups{"local"}});
	}
	elsif ( $path eq '.system.groups' ) {
	    ycp::Return (\%{$groups{"system"}});
	}
	elsif ( $path eq '.local.users.by_name' ) {
	    ycp::Return (\%{$users_by_name{"local"}});
	}
	elsif ( $path eq '.system.users.by_name' ) {
	    ycp::Return (\%{$users_by_name{"system"}});
	}
	elsif ( $path eq '.local.users.uids' ) {
	    ycp::Return (\%{$uids{"local"}});
	}
	elsif ( $path eq '.system.users.uids' ) {
	    ycp::Return (\%{$uids{"system"}});
	}
	elsif ( $path eq '.local.users.usernames' ) {
	    ycp::Return (\%{$usernames{"local"}});
	}
	elsif ( $path eq '.system.users.usernames' ) {
	    ycp::Return (\%{$usernames{"system"}});
	}
	elsif ( $path eq '.local.users.homes' ) {
	    ycp::Return (\%{$homes{"local"}});
	}
	elsif ( $path eq '.system.users.homes' ) {
	    ycp::Return (\%{$homes{"system"}});
	}
	elsif ( $path eq '.local.users.last_uid' ) {
	    ycp::Return ($last_uid{"local"});
	}
	elsif ( $path eq '.system.users.last_uid' ) {
	    ycp::Return ($last_uid{"system"});
	}
	elsif ( $path eq '.local.groups.by_name' ) {
	    ycp::Return (\%{$groups_by_name{"local"}});
	}
	elsif ( $path eq '.system.groups.by_name' ) {
	    ycp::Return (\%{$groups_by_name{"system"}});
	}
	elsif ( $path eq '.local.groups.gids' ) {
	    ycp::Return (\%{$gids{"local"}});
	}
	elsif ( $path eq '.system.groups.gids' ) {
	    ycp::Return (\%{$gids{"system"}});
	}
	elsif ( $path eq '.local.groups.groupnames' ) {
	    ycp::Return (\%{$groupnames{"local"}});
	}
	elsif ( $path eq '.system.groups.groupnames' ) {
	    ycp::Return (\%{$groupnames{"system"}});
	}
	elsif ( $path eq '.passwd.plusline' ) {
	    ycp::Return ($plus_line_passwd);
	}
	elsif ( $path eq '.shadow.plusline' ) {
	    ycp::Return ($plus_line_shadow);
	}
	elsif ( $path eq '.group.plusline' ) {
	    ycp::Return ($plus_line_group);
	}
	else {
	    y2error ("wrong path ($path) or argument: ", ref ($argument));
	    ycp::Return("false");
	}
    }
    elsif ( $command eq "Write" )
    {
	if ( $path eq '.users' && ref ($argument) eq "HASH" ) {
	    if (write_passwd ($argument)) {
		ycp::Return ("true");
	    }
	    else {
		ycp::Return ("false");
	    }
	}
	elsif ( $path eq '.shadow' && ref ($argument) eq "HASH" ) {
	    if (write_shadow ($argument)) {
		ycp::Return ("true");
	    }
	    else {
		ycp::Return ("false");
	    }
	}
	elsif ( $path eq '.groups' && ref ($argument) eq "HASH" ) {
	    if (write_group ($argument)) {
		ycp::Return ("true");
	    }
	    else {
		ycp::Return ("false");
	    }
	}
	elsif ( $path eq '.passwd.plusline' ) {
	    if ($argument eq $plus_line_passwd) {
		ycp::Return ("false");
	    }
	    else {
		$plus_line_passwd = $argument;
		ycp::Return ("true");
	    }
	}
	elsif ( $path eq '.group.plusline' ) {
	    if ($argument eq $plus_line_group) {
		ycp::Return ("false");
	    }
	    else {
		$plus_line_group = $argument;
		ycp::Return ("true");
	    }
	}
	elsif ( $path eq '.shadow.plusline' ) {
	    if ($argument eq $plus_line_shadow) {
		ycp::Return ("false");
	    }
	    else {
		$plus_line_shadow = $argument;
		ycp::Return ("true");
	    }
	}
	else {
	    y2error ("wrong path ($path) or argument type: ",  ref ($argument));
	    ycp::Return("false");
	}
    }
    elsif ( $command eq "result")
    {
	exit;
    }
    else
    {
	y2error ("wrong command: $command");
	ycp::Return("wrong command ($command)");
    }
}

# end
